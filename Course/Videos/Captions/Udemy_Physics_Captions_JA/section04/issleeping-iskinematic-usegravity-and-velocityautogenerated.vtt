WEBVTT

00:00.840 --> 00:04.980
重力と速度の運動学的な使用です。

00:05.010 --> 00:09.480
このビデオでは、これらの非常に強力で便利な物理学的特性について説明します。

00:09.480 --> 00:13.380
このビデオでは、各オブジェクトの物理演算のオンとオフについて説明します。

00:13.470 --> 00:15.720
なぜそうしたいのかを学びます。

00:15.720 --> 00:17.490
次にUnityのエディタを開きます。

00:17.510 --> 00:19.020
プロパティをいじります。

00:19.020 --> 00:21.820
重要な物理プロパティをおさらいしましょう。

00:21.840 --> 00:25.370
立方体が積み重なっていて、そのうちの1つが選択されているとします。

00:25.380 --> 00:30.750
そのキューブにはボックスコライダーがあり、プロパティと剛体があります。

00:30.960 --> 00:37.800
これらのプロパティのいくつかはインスペクタからアクセスできる。

00:37.800 --> 00:39.030
と重力を使う。

00:39.120 --> 00:45.480
しかし、いくつかのプロパティはコードからしかアクセスできません。

00:45.930 --> 00:48.510
剛体のキネマティックを見てみましょう。

00:48.510 --> 00:53.520
これはシステム内の物理がこの剛体に影響を与えるかどうかをコントロールします。

00:53.640 --> 00:55.860
デフォルトではfalseに設定されています。

00:55.860 --> 00:58.800
このゲームオブジェクトは物理制御の下で動作します。

00:58.920 --> 01:05.580
trueに設定すると、物理力の衝突や関節が無視されるようになります。

01:06.060 --> 01:12.660
この設定をtrueにすると、ゲームオブジェクトをスクリプトで動かすことができるようになります。

01:12.660 --> 01:13.680
物理システム

01:13.680 --> 01:16.290
シナリオによっては、それを切り替えることもできる。

01:16.290 --> 01:20.310
スクリプティングで駆動するゲームオブジェクトで、本当の意味で始めることができる。

01:20.400 --> 01:26.310
そして、例えばキャラクターが殴られたら、すぐにラグドールに変えることができる。

01:26.310 --> 01:28.260
(笑) --> 01:28.260 --> 01:28.260

01:28.260 --> 01:32.850
キネマティックを偽の剛体にして重力を利用する。

01:32.850 --> 01:36.690
重力が剛体に作用するかどうかをコントロールします。

01:37.110 --> 01:41.970
デフォルトではtrueに設定されており、重力を受けて落下します。

01:42.120 --> 01:44.610
時にはfalseに設定することもあります。

01:44.610 --> 01:50.580
重力の影響を受けない宇宙空間にいるような振る舞いをしたい場合や、より多くの重力を得たい場合は

01:50.580 --> 01:52.530
手動でオブジェクトをコントロールする

01:52.530 --> 01:55.440
モーション剛体は寝ています。

01:55.740 --> 02:00.570
これはプロパティではなく、括弧で囲まれたメソッドです。

02:00.570 --> 02:04.020
この後、プロパティと同じように値を取得することができます。

02:04.050 --> 02:06.930
これで剛体が寝ているかどうかがわかります。

02:06.930 --> 02:13.680
剛体の動きが非常に遅い場合、物理エンジンは剛体が停止したと判断し、次のように設定する。

02:13.680 --> 02:15.290
スリープモードに入ります。

02:15.300 --> 02:19.710
この最適化により、ほとんどの場合、プロセッサの処理時間を節約することができる。

02:19.710 --> 02:26.130
スリープとスリープ解除は自動的に行われるので、動いている時はスリープしていると考えればいいのです。

02:26.130 --> 02:29.880
を偽とし、最終的に静止している時は眠っていることを真とすればいい。

02:30.240 --> 02:36.090
例えば、キャラクターが動きを止めた時や、ゲーム内のアイテムが止まった時を検出することに焦点を当てます。

02:37.290 --> 02:43.230
例えば、キャラクターが的に向かって矢を放つと、矢は空中を飛び、やがて

02:43.230 --> 02:44.400
止まる

02:44.730 --> 02:48.030
矢が止まる時は寝ているのが正しい。

02:48.060 --> 02:52.980
それを確認して、よし、次の矢を放つ準備ができたと知ることができる。

02:53.400 --> 02:55.110
剛体速度

02:55.110 --> 03:00.990
剛体の速度ベクトルはこのベクトルで保持されます。

03:00.990 --> 03:03.750
これが剛体の速度ベクトルです。

03:03.750 --> 03:06.040
移動の方向と速度です。

03:06.060 --> 03:12.780
ほとんどの場合、非現実的な動作になる可能性があるので、速度を直接変更すべきではありません。

03:12.780 --> 03:14.610
ただし、例外もあります。

03:14.850 --> 03:20.700
典型的な使い方は、一人称視点のシューティングゲームですぐに速度を変更するような場合です。

03:26.640 --> 03:33.000
この場合、オブジェクトの速度を取得するために、設定せずに値にアクセスするのが一般的です。

03:33.000 --> 03:39.810
例えば、物理ベースの車のスピードメーターを画面に表示したい場合、次のようになります。

03:39.810 --> 03:40.710
この値

03:40.710 --> 03:43.320
物理演算をオフにしてみましょう。

03:43.320 --> 03:47.970
ゲームプレイ中に特定のオブジェクトの物理演算をオフにすることがあります。

03:47.970 --> 03:52.920
例えば、物理演算の代わりにマウス入力でオブジェクトを動かしたい。

03:52.920 --> 03:59.220
物理演算のオン・オフを切り替えたい場合は、ここで2つのプロパティを切り替える必要がある、

03:59.220 --> 04:03.660
重力を使うをfalseにし、運動力学をtrueにする。

04:03.660 --> 04:08.910
これで、剛体の動きをコードでコントロールできるようになりました。

04:08.910 --> 04:15.000
物理ベースの制御を行うには、use gravityをtrueに設定し、is kinematicをfalseに設定します。

04:15.000 --> 04:20.570
そうすれば、重力の下で、関節や物理的な力などを使って動作するようになります。

04:20.580 --> 04:25.620
では、これらのプロパティを使ったデモを作ってみましょう。

04:25.620 --> 04:27.960
ドロッパーゲームというシーンを作りました。

04:27.960 --> 04:29.160
シーンを再生してみましょう。

04:29.160 --> 04:30.930
とても単純なゲームです。

04:30.930 --> 04:35.340
この4つのプロパティがどのように使われているのかを見てみましょう。

04:35.340 --> 04:37.470
ユーザーの次のターンを待ちます。

04:37.470 --> 04:38.880
スリープ状態です。

04:38.880 --> 04:47.070
マウスのドラッグと落下の組み合わせで速度をUIに表示する。

04:47.070 --> 04:51.060
運動学的なプロパティと重力を利用したプロパティの2つを使う。

04:52.110 --> 04:52.410
よし。

04:52.410 --> 04:53.760
ユニティに戻る

04:54.240 --> 04:57.120
ゲームシーンを見てみましょう。

04:58.260 --> 05:02.910
そして、これらの物理プロパティがゲームプレイでどのように使われるかを見てみましょう。

05:03.150 --> 05:04.320
それではプレイしてみましょう。

05:10.350 --> 05:17.460
スポイトの箱が落下するときの速度と、スポイトの箱が落下するときの速度の2つです。

05:17.460 --> 05:19.800
画面はvelocityプロパティを使っています。

05:20.160 --> 05:27.630
次に、ボックスが落下し、下部のレールに当たった後、ボックス、次のボックスが使用可能になります。

05:27.630 --> 05:28.680
使えるようになった。

05:28.710 --> 05:33.390
数秒後、次のボックスが使えるようになる。

05:33.600 --> 05:39.660
次のボックスのis sleepingがtrueになるまで待つ。

05:39.960 --> 05:42.600
つまり、is sleepingはfalseです。

05:42.600 --> 05:47.040
そして、ついにヒットした時、彼らのスリーピングは真となり、再び私の番となる。

05:47.130 --> 05:48.630
これがプロパティの2つです。

05:49.080 --> 05:52.710
また、マウスでボックスを操作できることにも注目してください。

05:52.710 --> 05:58.650
剛体を使っていますが、手動で動かせるように設定しています。

05:58.830 --> 06:01.980
重力をオフにして、キネマティックをオンにします。

06:01.980 --> 06:09.470
そしてマウスでクリックしたら、キネマティックをオフにして重力をオンにする。

06:09.480 --> 06:11.040
そのコードを見てみよう。

06:16.740 --> 06:20.490
この4カ所にアクセスします。

06:20.490 --> 06:25.020
新しいスポイトを追加するたびに、物理プロパティにアクセスするコメントが表示されます。

06:25.020 --> 06:30.240
重力はfalse、運動学はtrueに設定しています。

06:30.240 --> 06:31.980
これでマウスコントロールができるようになりました。

06:33.720 --> 06:41.400
そして、毎フレーム呼び出されるアップデートで、マウスボタンをクリックすると、次のように切り替わる。

06:41.400 --> 06:44.700
重力を元に戻し、キネマティックをfalseにする。

06:44.700 --> 06:47.610
これで重力に従うようになる。

06:48.300 --> 06:52.980
また、アップデートで落下している間、アイチェックはスリープ状態です。

06:53.250 --> 06:56.040
寝ているということは、次のターンに備えているということです。

06:56.040 --> 06:58.830
点数を稼ぎ、次のターンへ。

06:59.840 --> 07:01.160
次のドロッパーをリリース。

07:02.570 --> 07:05.330
そして最後に

07:06.660 --> 07:14.190
最大速度を記録し、ブロックの最速時の速度に応じてポイントを与える。

07:14.400 --> 07:20.910
くだらないメカニズムだし、速度を使うための言い訳でもある。

07:20.910 --> 07:21.750
より高い位置から

07:21.750 --> 07:22.650
以上。

07:23.520 --> 07:29.010
次のビデオでは、物理学、リキャスト、リキャストコマンドスケジュールバッチを見てみましょう。

07:29.040 --> 07:33.450
このビデオでは、物理システムにおける空間クエリについて説明します。

07:33.450 --> 07:37.110
このビデオでは、物理システムにおける空間クエリについて説明します。
