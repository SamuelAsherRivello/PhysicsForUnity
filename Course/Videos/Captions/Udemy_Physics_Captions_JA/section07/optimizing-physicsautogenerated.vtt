WEBVTT

00:01.840 --> 00:03.150
物理学の最適化

00:03.160 --> 00:06.810
このビデオでは、物理学の実例を見てみましょう。

00:06.820 --> 00:09.220
最適化について実験します。

00:09.220 --> 00:12.700
最後に，パフォーマンスを劇的に向上させます。

00:13.030 --> 00:14.530
では、最適化してみましょう。

00:14.980 --> 00:19.560
同じチェーン・オブジェクトのインスタンスをたくさん使ったデモを作ってみました。

00:19.570 --> 00:22.810
20,000個のインスタンスを生成しています。

00:23.260 --> 00:25.420
現在のパフォーマンスは非常に低いです。

00:25.420 --> 00:28.420
私のノートパソコンでは1秒間に3フレーム程度です。

00:28.420 --> 00:31.900
もちろん、使用するマシンによってパフォーマンスは異なるかもしれない。

00:31.900 --> 00:36.100
60フレーム/秒を目標にしよう。

00:36.280 --> 00:38.500
最適化のために何ができるか考えてみよう。

00:40.620 --> 00:41.980
デモを見てみよう。

00:42.000 --> 00:44.720
最適化された物理学の開始シーンを使います。

00:44.730 --> 00:50.430
シーンを再生し、最適化を繰り返し、フレームレートをチェックします。

00:50.430 --> 00:51.480
どうなるか見てみよう。

00:52.110 --> 00:53.790
よし、プロジェクトに飛び込もう。

00:54.300 --> 00:57.150
最適化された開始シーンです。

00:57.540 --> 01:02.460
ここで設定したのはチェーンのリンクです。

01:02.640 --> 01:04.170
関節のある鎖ではありません。

01:04.170 --> 01:06.000
その断片を使ってるだけです。

01:06.000 --> 01:11.460
このウィンドウをもう少し開くと、Unityの統計が表示されます。

01:12.420 --> 01:18.300
この統計で、これらの破片が落下し、それぞれの欠陥と相互作用していることがわかる。

01:18.300 --> 01:18.840
となる。

01:18.840 --> 01:25.200
フレームレートは2.8～3フレーム/秒なので、非常に低速です。

01:25.860 --> 01:28.840
毎秒60フレームを目標にしよう。

01:28.890 --> 01:30.720
どんな変化があるか見てみよう。

01:32.070 --> 01:33.990
シーンの設定はいたってシンプルです。

01:33.990 --> 01:35.040
床がある

01:35.070 --> 01:40.680
それから、この中に2万個のオブジェクトがあります。

01:41.010 --> 01:42.420
それからシーン。

01:43.350 --> 01:46.630
Optimized Physics setupと呼ばれるゲームオブジェクトのセットアップ。

01:46.650 --> 01:50.200
コメントやコメントアウトされたコードの束です。

01:50.220 --> 01:51.690
一つ一つ見ていきましょう。

01:51.780 --> 01:56.850
まず、テストのアドバイスとして、これはプロジェクトをより効率的にするものではありません。

01:56.850 --> 02:00.270
このUIはフレームレートをより良く表示します。

02:00.390 --> 02:02.550
Vシンクのカウントをゼロにしました。

02:02.550 --> 02:09.660
最適化するために、最初の大きなステップはunityを最新のパブリックバージョンにアップグレードすることです。

02:09.660 --> 02:14.670
unityは常にシステム全体をアップデートしているからだ。

02:14.670 --> 02:18.510
レンダリングや物理演算など、unityは常にシステム全体をアップデートしているからだ。

02:18.600 --> 02:24.300
次に、もしフレームレートを重要視するのであれば、テスト中に、以下のようなフレームレートを実現することを検討してください。

02:24.300 --> 02:29.550
もし、フレームレートを重要視するのであれば、iOSやAndroidでビルドし、より近い環境でテストすることをお勧めします。

02:29.550 --> 02:37.080
エンドユーザーの体験に近づけることで、より良い、あるいはよりエンドユーザーの体験に近いパフォーマンスを得ることができます。

02:37.080 --> 02:39.510
これはもちろん重要なベンチマークである。

02:40.660 --> 02:43.390
まずはプロジェクト内でできることから始めてみよう。

02:43.720 --> 02:48.190
その3、シーンの影を消す。

02:48.220 --> 02:52.450
シーン内の床を静止させることもできます。

02:52.810 --> 03:00.100
物体のプレハブで、メッシュコライダーをオフにして、ボックスコライダーのようなプリミティブを使うことができます。

03:00.100 --> 03:00.700
代わりに

03:00.730 --> 03:03.940
この3つのステップを実行し、どのような変化が起こるか見てみよう。

03:04.450 --> 03:06.070
まずは照明から。

03:07.270 --> 03:10.660
硬い影ができました。

03:11.440 --> 03:13.630
ソフトシャドウより効率的

03:13.630 --> 03:15.370
しかし、シャドウなしで試してみよう。

03:15.370 --> 03:16.930
効果があるか見てみましょう。

03:16.930 --> 03:20.620
このようなことで、いくつかの違いが出てくるかもしれません。

03:21.880 --> 03:27.970
このような場合、マウスをクリックするとスピナーが動き出します。

03:28.780 --> 03:30.190
少なくとも最初は

03:30.190 --> 03:34.330
時間が経てば計算が増えるから遅くなるよ

03:34.330 --> 03:36.490
でも、少しはマシになるかもね。

03:36.490 --> 03:41.170
以前より3本に近いところで推移しているので、選択肢の一つとして考えてみてください。

03:42.180 --> 03:44.230
もちろん、あなたの試合には影が必要かもしれません。

03:44.290 --> 03:45.150
それは無理かもね。

03:45.150 --> 03:49.050
しかし、物理的でない解決方法があることを指摘しておきたい。

03:49.200 --> 03:54.120
次に見るのは、シンプルな床を設定することだ。

03:55.820 --> 04:00.980
|にできるようにあなたがそれをすることができます本当に出くわすことあなたは、実際には私のパートナーとi約束、誰でも素早くはちょうど無視これらの一見正確にどのように{}人のことを忘れることができます。

04:00.980 --> 04:02.030
それでは見てみよう。

04:02.650 --> 04:05.660
そういえば、ベストで3つくらいだったっけ。

04:06.580 --> 04:07.780
ここで

04:10.280 --> 04:11.780
ほぼ同じ

04:11.780 --> 04:16.010
少し変化がある可能性もあるが、それはチェックする必要がある。

04:16.640 --> 04:19.820
オブジェクトの数が多ければ、より多くのオブジェクトを静的に設定するのが良いでしょう。

04:19.850 --> 04:21.960
次にアレのプレハブを見てみましょう。

04:21.980 --> 04:25.190
これを世界に持ち出してズームインしてみましょう。

04:25.190 --> 04:28.430
メッシュコライダーがあるのがわかります。

04:28.430 --> 04:35.540
メッシュコライダーをオフにして、代わりにボックスコライダーを追加してみると、ボックスコライダーが

04:35.540 --> 04:38.600
は形状を推定するのに非常に良い仕事をしている。

04:38.600 --> 04:43.910
もちろん、角はもう丸くない。

04:43.910 --> 04:47.000
によって、物理学的な結果が違ってくるかもしれない。

04:47.300 --> 04:52.910
この変更をプレハブに保存し、どのように機能するか見てみましょう。

04:55.830 --> 04:58.020
マウスをクリックしてスタート。

05:03.740 --> 05:05.350
3点付近をウロウロしています。

05:06.850 --> 05:09.670
それなら大きな違いはなかったかもしれない。

05:10.720 --> 05:16.360
というわけで、本当に変更されたのか再確認してみる。

05:16.660 --> 05:17.880
ボックスコライダーができました。

05:17.890 --> 05:19.570
メッシュコライダーはオフです。

05:19.780 --> 05:21.550
メッシュコライダーを外します。

05:21.850 --> 05:23.800
意味があるのかわからないけど

05:24.800 --> 05:29.150
オフに切り替えても、フレームジャンプが起きないのが不思議です。

05:29.150 --> 05:31.730
少し改善された

05:35.810 --> 05:37.640
大きな差はないようだ。

05:37.640 --> 05:39.440
しかし、あなたのプロジェクトではそうかもしれません。

05:40.350 --> 05:41.490
次のステップに進みましょう。

05:42.850 --> 05:43.390
ここで

05:43.390 --> 05:47.200
いくつかの異なるタイム値があるので、それを微調整します。

05:47.410 --> 05:55.990
それぞれの値について、正確な物理学か効率的な物理学かの妥協点を探すことになる。

05:55.990 --> 05:56.740
フレームレート

05:56.980 --> 06:01.930
そのため、これらを微調整することで、計算の頻度を減らすことができます。

06:01.930 --> 06:03.360
以前より頻繁に

06:03.370 --> 06:08.110
このような調整で、私が事前に試した値は以下のようになった。

06:08.110 --> 06:08.890
いい結果が出た。

06:08.890 --> 06:09.760
それでは見てみよう。

06:10.800 --> 06:11.880
ここで走ります

06:15.850 --> 06:16.810
試してみましょう

06:18.030 --> 06:21.570
この差は大きい。

06:21.570 --> 06:24.330
この場合、これが本当に重要だと思う。

06:25.080 --> 06:28.830
おそらく、この変更だけを行い、他の変更は元に戻すことができるだろう。

06:28.830 --> 06:31.740
以前は1秒間に80フレームでした。

06:31.740 --> 06:35.100
目標の60フレームを達成した。

06:35.220 --> 06:39.450
この2つのプロパティのドキュメントを見れば、もう少し詳しくわかるだろう。

06:39.450 --> 06:41.700
この2つのプロパティが何をするものなのか、そしてなぜそれを調整することができるのかについて、もう少し詳しく知ることができます。

06:41.700 --> 06:46.800
そして、あなたのプロジェクトによっては、私のように極端に微調整することはできないかもしれない。

06:46.800 --> 06:49.920
正確さが必要かもしれない。

06:50.490 --> 06:53.790
このほかにもいくつか試したが、特に役には立たなかった。

06:54.330 --> 07:01.530
ここで設定できる物理的な設定がいくつかあり、それを設定する。

07:01.530 --> 07:04.020
を選択した。

07:04.020 --> 07:09.060
だから、それをこの会話に持ち込むつもりはない。

07:09.060 --> 07:10.050
他の価値観の微調整。

07:10.050 --> 07:13.320
そして最後に、設定の中にAdaptive Forceというものがあります。

07:13.320 --> 07:14.550
試してみます。

07:15.300 --> 07:22.680
物理プロジェクトの設定の物理で、アダプティブフォースを有効にします。

07:22.680 --> 07:25.110
デモではすでに有効になっています。

07:25.110 --> 07:30.780
つまり、大きなスタックの安定性を向上させる力が有効になるわけです。

07:30.780 --> 07:37.800
ということは、安定性は向上しそうですが、計算があるのでしょうから、より時間がかかりそうですね。

07:37.800 --> 07:38.160
そこで

07:38.160 --> 07:42.600
これをオフにして、パフォーマンスが悪化するかどうか見てみよう。

07:42.600 --> 07:44.250
パフォーマンスが上がった

07:46.400 --> 07:47.630
それとも変わらないか

07:48.320 --> 07:50.840
いい感じだ

07:52.970 --> 07:54.710
前

07:57.000 --> 07:59.230
ああ、今の方がいいね。

07:59.250 --> 08:03.840
適応機能をつけない方がいいということか。

08:04.380 --> 08:08.490
再生させるとシーンが複雑になるので、何とも言えない。

08:08.490 --> 08:14.250
つまり、フレームレートだけを見て視覚的に判断するのは科学的ではないということだ。

08:14.250 --> 08:19.830
しかし、全体的には以前よりもはるかにパフォーマンスが向上していることがわかる。

08:20.620 --> 08:20.890
現在

08:20.890 --> 08:23.320
もちろん、20,000個のオブジェクトを使用しています。

08:23.320 --> 08:29.950
フレームレートに問題があるようなら、あなたのゲームでも使えます。

08:29.950 --> 08:35.680
|にできるようになります。

08:36.160 --> 08:41.980
このような小さな変化を加えることで、よりドラマチックなフレームを作ることができる。

08:41.980 --> 08:44.470
そうすれば、わかるはずだ。

08:44.470 --> 08:45.790
なるほど、この機能は役に立つ。

08:45.790 --> 08:46.830
この機能は使えない

08:46.840 --> 08:51.880
そして、複雑さを取り除けば、より安定したフレームレートに戻る。

08:51.880 --> 08:53.950
これがあなたの望むゲームです。

08:53.950 --> 08:55.090
これで終了。

08:55.390 --> 09:00.520
また、最適化された物理演算の完成シーンを見れば、まったく同じ結果を見ることができる。

09:00.520 --> 09:04.600
しかし、あなたが実験しているように、もし飛び込みたいのであれば、いろいろと遊んでみて、それから自分自身を比較してみてください、

09:04.600 --> 09:05.400
そうすればいい。

09:05.410 --> 09:06.140
以上です。

09:06.160 --> 09:07.030
ありがとうございました。

09:09.720 --> 09:14.010
次回のビデオでは、物理学の軌跡の予測を見てみましょう。
